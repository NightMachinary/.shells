#!/usr/bin/env zsh
export AUTO_WHDEEP_MODE=y
(( ${+commands[realpath]} )) || {
  echo You need "realpath" from coreutils installed.
  exit 1
}
export MYDIR="$(realpath "${0:h}")/"
PATH="${MYDIR}autobin/:$PATH"

### Automatically generated code starts


&>/dev/null options=( posixargzero off autolist on printexitvalue off kshzerosubscript off histreduceblanks off chaselinks off extendedglob on localloops off histnostore off automenu on globcomplete off unset on listpacked off promptsubst on shwordsplit off pathdirs off kshtypeset off listtypes on warncreateglobal off promptbang off dotglob off braceexpand on listbeep on correctall off privileged off numericglobsort off histverify on trackall on histsubstpattern on globstarshort off cbases off rcquotes off posixaliases off histfindnodups off bashautolist off sharehistory on overstrike off kshautoload off incappendhistory on appendcreate off promptcr off mailwarn off pushdignoredups on interactive on ignoreeof off globsubst off rematchpcre on monitor on histsavebycopy on histbeep on debugbeforecmd on magicequalsubst off rmstarsilent on posixjobs off hashcmds on posixtraps off extendedhistory on notify on kshoptionprint off histexpiredupsfirst on glob on posixcd off braceccl off badpattern on longlistjobs on banghist on dvorak off alwaystoend on hashall on warnnestedvar off globalexport on ksharrays off correct off cdsilent off autonamedirs off histexpand on typesetsilent off rmstarwait off histnofunctions off autoparamslash on trapsasync off sunkeyboardhack off promptsp on histsavenodups off autocd on allexport off posixidentifiers off cshjunkiehistory off autopushd off completeinword on completealiases off aliases on autocontinue off appendhistory on aliasfuncdef off singlelinezle off hashlistall on ignoreclosebraces off recexact off localoptions off interactivecomments on errexit off cshjunkiequotes off markdirs off hashdirs on cdablevars off rcexpandparam off vi on printeightbit off multifuncdef on xtrace off login off cshjunkieloops off histappend on histignorespace on evallineno on shfileexpansion off rcs on functionargzero on errreturn off combiningchars off histignoredups on histfcntllock off beep on autoremoveslash on hup on globdots off checkrunningjobs on autoparamkeys on shnullcmd off multibyte on zle on promptpercent on flowcontrol off continueonerror off incappendhistorytime off autoresume off globassign off caseglob off shortloops on bsdecho off cprecedences off log on transientrprompt off verbose off localpatterns off ignorebraces off pipefail off equals on menucomplete off cshnullglob off casematch on promptvars on histallowclobber off bareglobqual on shinstdin on restricted off pushdminus on nullglob off chasedots off mailwarning off listambiguous on cshnullcmd off bashrematch off octalzeroes off forcefloat off exec on multios on emacs off nomatch on pathscript off localtraps off stdin on onecmd off kshglob off clobber on posixbuiltins off alwayslastprompt on pushdtohome off histignorealldups off hashexecutablesonly off pushdsilent off shoptionletters off physical off sourcetrace off histlexwords off bgnice on globalrcs on posixstrings off checkjobs on shglob off singlecommand off listrowsfirst off )

alias m_doc=':'

alias unt='\noglob _noglob_unt'
_noglob_unt () {
	isI && test -z "$*" && set -- "$(pbpaste)"
	local note="$(url2note "$@")" 
	print -r -- $note
	if isI
	then
		pbcopy $note
	fi
}
_noglob_unt () {
	isI && test -z "$*" && set -- "$(pbpaste)"
	local note="$(url2note "$@")" 
	print -r -- $note
	if isI
	then
		pbcopy $note
	fi
}
isI () {
	! test -z "$FORCE_INTERACTIVE" || [[ -o interactive ]]
}
pbpaste () {
	(( $+commands[copyq] )) && {
		copyq clipboard
	} || {
		(( $+commands[pbpaste] )) && command pbpaste
	}
}
alias url2note='\noglob _noglob_url2note'
_noglob_url2note () {
	run-on-each _reify_url2note "$@"
}
_reify_url2note () {
	local url="$1" 
	local title="$(urlmeta $url title)" 
	local desc="$(urlmeta $url description)" 
	local img="$(urlmeta $url image)" 
	print -r -- "* [${title:-$url}]($url)"
	test -z "$desc" || print -r -- "  * $desc"
	test -z "$title" || print -r -- "  * $url"
	test -z "$img" || print -r -- "![]($img)"
}
pbcopy () {
	local in="$(in-or-args "$@")" 
	(( $+commands[copyq] )) && {
		copyq copy -- "$in" &> /dev/null
	} || {
		(( $+commands[pbcopy] )) && command pbcopy <<< "$in"
	}
}
_noglob_url2note () {
	run-on-each _reify_url2note "$@"
}
run-on-each () {
	\noglob : Use unusual name not to shadow actual vars
	local i98765
	for i98765 in "${@:2}"
	do
		eval "$1 $(gquote "$i98765")"
	done
}
urlmeta () {
	m_doc "$*" "$0" "" "$0 <url> <req>
gets the requested metadata." | {
		eval "$(< /dev/stdin)"
	}
	local url="$1" 
	local html="$(eval-memoi gurl $url)" f="$(mktemp)" 
	print -r -- $html > $f
	htmlf=$f req="${2:-title}" python3 -W ignore -c "
import metadata_parser, os, sys
page = metadata_parser.MetadataParser(html=open(os.environ['htmlf'], 'r').read())
if os.environ.get('DEBUGME',''):
   print(page.metadata, file=sys.stderr)
   # from IPython import embed; embed()
print(page.get_metadata(os.environ['req']) or '')
"
	\rm -f $f
}
title () {
	emulate -L zsh
	setopt prompt_subst
	[[ "$EMACS" == *term* ]] && return
	: ${2=$1}
	case "$TERM" in
		(cygwin | xterm* | putty* | rxvt* | konsole* | ansi) print -Pn "\e]2;$2:q\a"
			print -Pn "\e]1;$1:q\a" ;;
		(screen* | tmux*) print -Pn "\ek$1:q\e\\" ;;
		(*) if [[ "$TERM_PROGRAM" == "iTerm.app" ]]
			then
				print -Pn "\e]2;$2:q\a"
				print -Pn "\e]1;$1:q\a"
			else
				if [[ -n "$terminfo[fsl]" ]] && [[ -n "$terminfo[tsl]" ]]
				then
					echoti tsl
					print -Pn "$1"
					echoti fsl
				fi
			fi ;;
	esac
}
in-or-args () {
	(( $# )) && print -r -- "$@" || print -r -- "${$(</dev/stdin ; ec .)%.}"
}
gquote () {
	\noglob : Use this to control quoting centrally.
	print -r -- "${(q+@)@}"
}
alias eval-memoi=memoi-eval
memoi-eval () {
	local now="$(date +%s)" 
	local cmd="$(gq "$@")" 
	redis-cli --raw ping &> /dev/null || {
		test -n "$memoi_strict" && {
			ecerr '`redis-cli ping` failed. Please make sure redis is up.'
			return 33
		} || eval "$cmd"
	}
	{
		(( $(redis-cli --raw exists $cmd) )) && {
			(( memoi_expire == 0 )) || {
				((memoi_expire >= 0 )) && (( (now - $(redis-cli --raw hget $cmd timestamp)) <= memoi_expire ))
			}
		}
	} && {
		redis-cli --raw hexists $cmd stdout &> /dev/null && print -r -- "$(redis-cli --raw hget $cmd stdout)"
		redis-cli --raw hexists $cmd stderr &> /dev/null && print -r -- "$(redis-cli --raw hget $cmd stderr)"
		(
			exit 0
		)
	} || {
		local errfile="$(mktemp)" 
		local out
		out="$(eval "$cmd" 2>"$errfile")" 
		redis-cli hset $cmd exit $? &> /dev/null
		redis-cli -x hset $cmd stdout <<< "$out" &> /dev/null
		redis-cli -x hset $cmd stderr &> /dev/null < $errfile
		\rm "$errfile"
		redis-cli hset $cmd timestamp "$(date +%s)" &> /dev/null
		redis-cli --raw hexists $cmd stdout &> /dev/null && print -r -- "$(redis-cli --raw hget $cmd stdout)"
		redis-cli --raw hexists $cmd stderr &> /dev/null && print -r -- "$(redis-cli --raw hget $cmd stderr)"
	}
	return $(redis-cli --raw hget $cmd exit)
}
alias gurl='curlm -o /dev/stdout'
curlm () {
	curl --silent --fail --location --header "$(cookies-auto "$@")" "$@"
}
alias ec='print -r --'
print: shell built-in command
memoi-eval () {
	local now="$(date +%s)" 
	local cmd="$(gq "$@")" 
	redis-cli --raw ping &> /dev/null || {
		test -n "$memoi_strict" && {
			ecerr '`redis-cli ping` failed. Please make sure redis is up.'
			return 33
		} || eval "$cmd"
	}
	{
		(( $(redis-cli --raw exists $cmd) )) && {
			(( memoi_expire == 0 )) || {
				((memoi_expire >= 0 )) && (( (now - $(redis-cli --raw hget $cmd timestamp)) <= memoi_expire ))
			}
		}
	} && {
		redis-cli --raw hexists $cmd stdout &> /dev/null && print -r -- "$(redis-cli --raw hget $cmd stdout)"
		redis-cli --raw hexists $cmd stderr &> /dev/null && print -r -- "$(redis-cli --raw hget $cmd stderr)"
		(
			exit 0
		)
	} || {
		local errfile="$(mktemp)" 
		local out
		out="$(eval "$cmd" 2>"$errfile")" 
		redis-cli hset $cmd exit $? &> /dev/null
		redis-cli -x hset $cmd stdout <<< "$out" &> /dev/null
		redis-cli -x hset $cmd stderr &> /dev/null < $errfile
		\rm "$errfile"
		redis-cli hset $cmd timestamp "$(date +%s)" &> /dev/null
		redis-cli --raw hexists $cmd stdout &> /dev/null && print -r -- "$(redis-cli --raw hget $cmd stdout)"
		redis-cli --raw hexists $cmd stderr &> /dev/null && print -r -- "$(redis-cli --raw hget $cmd stderr)"
	}
	return $(redis-cli --raw hget $cmd exit)
}
alias gq=gquote
gquote () {
	\noglob : Use this to control quoting centrally.
	print -r -- "${(q+@)@}"
}
ecerr () {
	color 255 43 244 "$@" >&2
}
curlm () {
	curl --silent --fail --location --header "$(cookies-auto "$@")" "$@"
}
cookies-auto () {
	m_doc "$*" "$0" "" "Returns theCookies if present. Otherwise tries to get the cookies from the first url in args." | {
		eval "$(< /dev/stdin)"
	}
	test -n "$caDisableCookies" && return 0
	local ci='' 
	if test -z "$theCookies"
	then
		local i
		for i in $@
		do
			if [[ "$i" =~ '^http' ]]
			then
				c="$(cookies "$i")" 
				break
			fi
		done
	else
		c="$(cookies)" 
	fi
	print -r -- "$c"
}
color () {
	true colorfg colorbg
	local in inargs
	local noreset="$coNr" 
	local nonewline="$coN" 
	\noglob : "Note that we need to first get stdin and then print the color, otherwise we'll print the color before anything has been outputted, resulting in race conditions."
	[[ "$1" =~ '^\d+$' ]] && {
		in-or-args2 "${@[4,-1]}"
		"${co_f:-colorfg}" "$@"
	} || {
		in-or-args2 "${@[2,-1]}"
		isI && printf %s "$fg[$1]"
	}
	in="$inargs" 
	print -nr -- "$in"
	test -n "$noreset" || resetcolor
	test -n "$nonewline" || echo
}
cookies () {
	m_doc "$*" "$0" "" "$0 [<cookie-or-url>=theCookies]
Outputs in header style." | {
		eval "$(< /dev/stdin)"
	}
	local url="$1" 
	local env_c="$theCookies" 
	local c="Cookie:$1" 
	if [[ "$url" =~ '^http' ]]
	then
		c="Cookie:$(getcookies "$url")" 
	fi
	test -z "$url" && c="Cookie:${env_c}" 
	print -r -- "$c"
}
colorfg () {
	! isI || printf "\x1b[38;2;${1:-0};${2:-0};${3:-0}m"
}
colorbg () {
	! isI || printf "\x1b[48;2;${1:-0};${2:-0};${3:-0}m"
}
inargs () {
	reval "$@" "$(in-or-args)"
}
in-or-args2 () {
	(( $# )) && inargs=("$@")  || inargs="${$(</dev/stdin ; ec .)%.}" 
}
resetcolor () {
	\noglob : 'This var is builtin in zsh'
	! isI || printf %s "$reset_color"
}
getcookies () {
	m_doc "$*" "$0" "" "[cookiesFile= ] $0 <url>
Will output Chrome's cookies for the given URL in key=val;key2=val2
See |cookies| for higher-level API." | {
		eval "$(< /dev/stdin)"
	}
	local url="$1" 
	local cf="${cookiesFiles:-${HOME}/Library/Application Support/Google/Chrome/Default/Cookies}" 
	test -e "$cf" || {
		ecdbg "getcookies called with non-existent file: $cf"
		return 0
	}
	cookiesFile="$cf" url="$url" python -c '
from pycookiecheat import chrome_cookies
import os
url = os.environ["url"]
HOME = os.environ["HOME"]
cookiesFile = os.environ["cookiesFile"]
cookies = chrome_cookies(url, cookie_file=cookiesFile)
#print(cookies)
out = ""
for k,v in cookies.items():
    out += f"{k}={v};"
print(out[:-1])
'
}
reval () {
	eval "$(gq "$@")"
}
alias s=silent
alias silent='&>/dev/null'
ecdbg () {
	isNotDbg || {
		local errcol=("${debugcol[@]:-cyan}") 
		color "$errcol[@]" "$@" >&2
	}
}
isNotDbg () {
	! isDbg
}
isDbg () {
	test -n "$DEBUGME"
}
### Automatically generated code ends

test -n "$autowhdeepwarning" || {
echo "######"
echo This script has been automatically generated from my zsh files. It probably works, but there is a minute chance that some functions/aliases needed might be missing. You need to install the requisite binaries for this script to work. You also need an up-to-date zsh with support for re_match_pcre, though things may work without it if you are very lucky.
 echo Files at '/home/eva/scripts/' can be found on my repo github.com/NightMachinary/.shells . They should be included in the folder 'autobin' near the generated script, but if not, just download them and add to PATH manually. Please note that these scripts' dependencies have NOT been included. It has been my hope that they don't have any or what they require is obvious through the error messages. I have included pip and npm packages that I use globally in the folder 'autodeps', and installing all of them might make things easier.
echo 'Needed binaries (this list might not be exhaustive, and some of these might actually NOT be needed):
coreutils
moreutils
findutils
/usr/bin/copyq
/home/linuxbrew/.linuxbrew/bin/clipboard
/home/linuxbrew/.linuxbrew/bin/image
/bin/mktemp
/home/eva/miniconda3/bin//python3
/home/linuxbrew/.linuxbrew/bin/page
/home/linuxbrew/.linuxbrew/bin/zsh
/bin/date
/usr/bin/redis-cli
/bin/ping
/usr/bin/make
/home/linuxbrew/.linuxbrew/bin/curl
/home/eva/miniconda3/bin//python
'
 echo Set the environment variable \"autowhdeepwarning\" to \"no\" to avoid seeing this message. ; echo "######" ; echo }

unt "$@"
